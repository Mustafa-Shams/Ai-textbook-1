"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[8802],{1839(e,s,n){n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var i=n(4848),r=n(8453);const t={sidebar_position:4,title:"rclpy Implementation Examples"},l="rclpy Implementation Examples",a={id:"module-1/rclpy-examples",title:"rclpy Implementation Examples",description:"This section provides practical implementation examples using rclpy, the Python client library for ROS 2. These examples demonstrate the fundamental patterns of publisher-subscriber communication that form the backbone of robotic systems. Understanding these patterns is crucial for developing real-world robotic applications where multiple components must coordinate seamlessly.",source:"@site/docs/module-1/rclpy-examples.md",sourceDirName:"module-1",slug:"/module-1/rclpy-examples",permalink:"/Ai-textbook-1/docs/module-1/rclpy-examples",draft:!1,unlisted:!1,editUrl:"https://github.com/Mustafa-Shams/ai-textbook/tree/main/website/docs/module-1/rclpy-examples.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"rclpy Implementation Examples"},sidebar:"tutorialSidebar",previous:{title:"Core Concepts: Nodes, Topics, Services",permalink:"/Ai-textbook-1/docs/module-1/concepts"},next:{title:"URDF Structures for Humanoid Joints/Links",permalink:"/Ai-textbook-1/docs/module-1/urdf-structures"}},o={},c=[{value:"Publisher Node",id:"publisher-node",level:2},{value:"Publisher Node with Advanced Features",id:"publisher-node-with-advanced-features",level:2},{value:"Subscriber Node",id:"subscriber-node",level:2},{value:"Advanced Subscriber Node",id:"advanced-subscriber-node",level:2},{value:"Service Client and Server Examples",id:"service-client-and-server-examples",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"rclpy-implementation-examples",children:"rclpy Implementation Examples"}),"\n",(0,i.jsx)(s.p,{children:"This section provides practical implementation examples using rclpy, the Python client library for ROS 2. These examples demonstrate the fundamental patterns of publisher-subscriber communication that form the backbone of robotic systems. Understanding these patterns is crucial for developing real-world robotic applications where multiple components must coordinate seamlessly."}),"\n",(0,i.jsx)(s.p,{children:"The examples provided here serve as templates for more complex implementations you'll encounter in humanoid robotics applications. Each pattern can be extended with additional features such as parameter management, custom message types, and sophisticated data processing pipelines."}),"\n",(0,i.jsx)(s.h2,{id:"publisher-node",children:"Publisher Node"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(s.h2,{id:"publisher-node-with-advanced-features",children:"Publisher Node with Advanced Features"}),"\n",(0,i.jsx)(s.p,{children:"A more sophisticated publisher node might include error handling, parameter management, and custom message types:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import JointState\nimport math\n\nclass AdvancedPublisher(Node):\n    def __init__(self):\n        super().__init__('advanced_publisher')\n\n        # Create publisher with custom QoS settings\n        self.publisher_ = self.create_publisher(String, 'robot_status', 10)\n\n        # Publisher for joint states (common in humanoid robots)\n        self.joint_publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Declare parameters with default values\n        self.declare_parameter('publish_rate', 1.0)\n        self.declare_parameter('robot_name', 'humanoid_robot')\n\n        # Get parameter values\n        publish_rate = self.get_parameter('publish_rate').value\n        self.robot_name = self.get_parameter('robot_name').value\n\n        # Create timer based on parameter\n        self.timer = self.create_timer(1.0 / publish_rate, self.timer_callback)\n        self.i = 0\n\n        self.get_logger().info(f'Advanced publisher started for {self.robot_name}')\n\n    def timer_callback(self):\n        # Publish status message\n        status_msg = String()\n        status_msg.data = f'{self.robot_name} status: operational - cycle {self.i}'\n        self.publisher_.publish(status_msg)\n\n        # Publish joint states (simulated for humanoid robot)\n        joint_msg = JointState()\n        joint_msg.header.stamp = self.get_clock().now().to_msg()\n        joint_msg.name = ['hip_joint', 'knee_joint', 'ankle_joint']\n        joint_msg.position = [\n            math.sin(self.i * 0.1),      # Hip\n            math.cos(self.i * 0.15),     # Knee\n            math.sin(self.i * 0.2)       # Ankle\n        ]\n        self.joint_publisher.publish(joint_msg)\n\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    advanced_publisher = AdvancedPublisher()\n    rclpy.spin(advanced_publisher)\n    advanced_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(s.h2,{id:"subscriber-node",children:"Subscriber Node"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(s.h2,{id:"advanced-subscriber-node",children:"Advanced Subscriber Node"}),"\n",(0,i.jsx)(s.p,{children:"An advanced subscriber might include multiple subscriptions, message filtering, and complex processing:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\n\nclass AdvancedSubscriber(Node):\n    def __init__(self):\n        super().__init__('advanced_subscriber')\n\n        # Multiple subscriptions for different message types\n        self.status_sub = self.create_subscription(\n            String, 'robot_status', self.status_callback, 10)\n        self.joint_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, 10)\n        self.cmd_sub = self.create_subscription(\n            Twist, 'cmd_vel', self.velocity_callback, 10)\n\n        # Publisher for processed data\n        self.result_pub = self.create_publisher(String, 'processed_data', 10)\n\n        self.joint_data = None\n        self.velocity_data = None\n\n    def status_callback(self, msg):\n        self.get_logger().info(f'Status received: {msg.data}')\n\n        # Process status and potentially publish result\n        result_msg = String()\n        result_msg.data = f'Processed: {msg.data}'\n        self.result_pub.publish(result_msg)\n\n    def joint_callback(self, msg):\n        self.joint_data = msg\n        self.get_logger().info(f'Joint positions: {msg.position[:3]}...')\n\n    def velocity_callback(self, msg):\n        self.velocity_data = msg\n        self.get_logger().info(f'Velocity command: {msg.linear.x}, {msg.angular.z}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    advanced_subscriber = AdvancedSubscriber()\n    rclpy.spin(advanced_subscriber)\n    advanced_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(s.p,{children:"These examples demonstrate the fundamental publish-subscribe pattern in ROS 2. In real robotic applications, publishers might represent sensor data (camera images, LIDAR scans, IMU readings) while subscribers might represent control systems that react to this data. The publisher-subscriber pattern enables loose coupling between components, allowing for more robust and maintainable robotic systems."}),"\n",(0,i.jsx)(s.h2,{id:"service-client-and-server-examples",children:"Service Client and Server Examples"}),"\n",(0,i.jsx)(s.p,{children:"In addition to publishers and subscribers, ROS 2 nodes often implement service clients and servers for synchronous communication:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Service Server:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Returning {response.sum}')\n        return response\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Service Client:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClient(Node):\n    def __init__(self):\n        super().__init__('minimal_client')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n"})}),"\n",(0,i.jsx)(s.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(s.p,{children:"Explore URDF structures for humanoid joints and links. The programming patterns demonstrated here will be essential as you work with more complex robotic systems and integrate various components of your humanoid robot."})]})}function m(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);